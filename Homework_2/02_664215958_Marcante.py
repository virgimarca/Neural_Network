# -*- coding: utf-8 -*-
"""02-664215958-Marcante.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SK4b6-xNuhra-mIZO4trS2HfFLWXj7z-
"""

import numpy as np
import matplotlib.pyplot as plt

np.random.seed(2024)
w_0 = np.random.uniform(-1/4, 1/4)
w_1, w_2 = np.random.uniform(-1, 1), np.random.uniform(-1, 1)
#S = np.random.uniform(-1, 1, (100, 2))
S = np.random.uniform(-1, 1, (1000, 2))
w_0, w_1, w_2

S_1 = []
S_0 = []
for x in S:
  res = w_0 + x[0] * w_1 + x[1] * w_2
  if res >= 0:
    S_1.append(x)
  else:
    S_0.append(x)

fig, ax = plt.subplots()
x = np. linspace(-1,1,100)
y = -w_1/w_2*x-w_0/w_2
line = ax.plot(x, y, '-b', label='decision boundary')
xs_1 = [x[0] for x in S_1]
ys_1 = [x[1] for x in S_1]
ax.plot(xs_1, ys_1, '+', label= 'points in S_1' )
xs_2 = [x[0] for x in S_0]
ys_2 = [x[1] for x in S_0]
ax.plot(xs_2, ys_2, '*', label = 'points in S_0')
plt.title('Graph of x_2=-w_1/w_2*x_1-w_0/w_2')
plt.xlabel('x_1')
plt.ylabel('x_2')
lgd = ax.legend(loc = 'upper center', bbox_to_anchor = (0.5, -0.15), ncol = 3, fancybox = True)
plt.savefig('perceptron_decision_boundary_100.eps', format='eps', bbox_extra_artists = (lgd,), bbox_inches = 'tight') 
plt.show()

def indicator(x):
  if x >= 0:
    return 1
  else:
    return 0

np.random.seed(2022)
w = np.random.uniform(-1, 1, (1, 3))
print(f'Starting value for w: {w}')
#eta = 1
#eta = 10
eta = 0.1
epoch = 0
n_misclass = []
u = indicator
misclass = 100
a = np.array([1])
while  misclass != 0:
  epoch+=1
  misclass = 0
  for x in S:
    t = np.concatenate((a, x), axis = 0)
    y =  u(w.dot(t))
    label =  u(w_0 + w_1* x[0] + w_2 * x[1])
    #print(label)

    if y != label:
      if label == 1:
        w = w + eta*t
        misclass+=1

      if label == 0:
        w = w - eta*t
        misclass+=1

  n_misclass.append(misclass)
print(f'Value found by the perceptron algorithm of w: {w}')

fig, ax = plt.subplots()
x = np. linspace(-1,1,100)
y =  -w_1/w_2*x-w_0/w_2
ax.plot(x, y, '-b', label='decision boundary')
y_2 =  -w[0][1]/w[0][2]*x-w[0][0]/w[0][2]
ax.plot(x, y_2, '-r', label='found decision boundary')
xs_1 = [x[0] for x in S_1]
ys_1 = [x[1] for x in S_1]
ax.plot(xs_1, ys_1, '+', label= 'points in S_1' )
xs_2 = [x[0] for x in S_0]
ys_2 = [x[1] for x in S_0]
ax.plot(xs_2, ys_2, '*', label = 'points in S_0')
plt.title('Graph of x_2=-w_1/w_2*x_1-w_0/w_2')
plt.xlabel('x_1')
plt.ylabel('x_2')
lgd = ax.legend(loc = 'upper center', bbox_to_anchor = (0.5, -0.15), ncol = 2, fancybox = True)
plt.savefig('predicted_boundary_100.eps', format='eps', bbox_extra_artists = (lgd,), bbox_inches = 'tight') 
plt.show()

plt.plot( n_misclass, '-b', label='x_2=-w_1/w_2*x_1-w_0/w_2')
#plt.title('Perceptron with 100 samples and eta = 1')
#plt.title('Perceptron with 1000 samples and eta = 1')
#plt.title('Perceptron with 100 samples and eta = 10')
#plt.title('Perceptron with 1000 samples and eta = 10')
#plt.title('Perceptron with 100 samples and eta = 0.1')
plt.title('Perceptron with 1000 samples and eta = 0.1')
plt.xlabel('epochs')
plt.ylabel('misclassifications')
#plt.savefig('misclassification_eta_1_samples_100.eps', format='eps')
#plt.savefig('misclassification_eta_1_samples_1000.eps', format='eps')
#plt.savefig('misclassification_eta_10_samples_100.eps', format='eps')
#plt.savefig('misclassification_eta_10_samples_1000.eps', format='eps')
#plt.savefig('misclassification_eta_0.1_samples_100.eps', format='eps')
plt.savefig('misclassification_eta_0.1_samples_1000.eps', format='eps')